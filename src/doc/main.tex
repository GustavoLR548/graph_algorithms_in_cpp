\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{tikz} 
\usetikzlibrary{automata, arrows, positioning}

\usepackage{listings}
\usepackage{xcolor}

\usepackage[utf8]{inputenc}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
     
\sloppy

\title{Estudo de diferentes formas de enumeração de ciclos em um grafo}

\author{Gustavo Lopes Rodrigues\inst{1}, Thiago Henriques Nogueira\inst{2},}


\address{Instituto de Ciências e Informática \\Pontifícia Universidade Católica de Minas Gerais
  (PUC-MG)\\}


\begin{document} 

  \maketitle

  \begin{abstract} 
    This document serves as a report on the study in two different ways
    to enumerate cycles within a graph: permutation and walking. For this
    study, we only work with non-directed graphs. In order to test the effiency 
    of both algorythms,we also implemented a method to calculate the performance of walking
    X permutation as the graph increases.
  \end{abstract}

  \begin{resumo} 
    Este documento serve é um relatório sobre o estudo em duas maneiras 
    diferentes de enumerar ciclos dentro de um grafo: permutação e por caminhamento. Para esse 
    estudo, trabalhamos apenas com grafos não-direcionado. Então fizemos um método
    para calcular o desempenho do caminhamento e da permutação, na medida que o grafo aumentasse.
  \end{resumo}


  \section{Informações gerais}

    Este é um trabalho feita para a disciplina de Algoritmo em Grafos, para a 
    \emph{Pontifícia Universidade Católica de Minas Gerais}, onde foi necessário 
    implementar duas maneiras diferentes de enumerar todos os ciclos dentro de um 
    grafo não direcionado: permutação e caminhamento. O objetivo final  deste relatório, 
    é de descrever toda a implementação do grafo e da resolução do problema, assim como 
    comparar ambos os algoritmos em questão do desempenho.

    Na seção \ref{sec:graph}, detalhamos a estrutura de grafo que foi usada para essa atividade,
    assim também como os seus principais componentes. Em \ref{sec:permutation} e \ref{sec:walking},
    detalhamos como implementos os nossos algoritmos de permutação e caminhamento respectivamente.
    A seção \ref{sec:performance} é a demonstração da performance dos códigos, assim como também 
    os grafos utilizados para os testes e como fizemos os testes. Por fim, na seção \ref{sec:conclusion}
    concluímos o trabalho com nossas perspectivas.

  \section{Grafo} \label{sec:graph}

    Para maior organizações, todas as classes implementadas possuem um header (arquivo .hpp)
    e o grafo não é uma exceção. Em graph.hpp é colocado todas as variáveis, assim também como as 
    funções usadas pelo grafo. Em graph.cpp, todas as declarações feitas no arquivo .hpp, são 
    implementadas.
    
    Para o nosso próposito, apenas duas estruturas foram usadas para guardar informações sobre
    o grafo: primeiro temos um vetor , com um vetor de indíces. A ideia é colocar listas flexíveis,
    onde cada posição representa os adjacentes de determinada vértice. Essa estrutura é muito
    importante para a permutação. 

    \begin{lstlisting}[language=c++]
      
      std::vector<std::vector<counter>> adj;
    \end{lstlisting}

    Para o caminhamento, utilizamos também um vetor, porém um vetor com um par(std::pair): 
    o primeiro é o peso, o segundo é outro par, porém este possui a vértice de entrada(source)
    e destino(destination). Basicamente esta estrutura guarda as relações entre as arestas 
    do grafo, assim como o peso dessas relações.

    \begin{lstlisting}[language=c++]
      
      std::vector<std::pair<weight,std::pair<counter,counter>>> edges_weights;
    \end{lstlisting}

    Os outros dois atributos referem-se apenas aos contadores de vértices e arestas.

    Com todos os atributos mencionados, agora vamos para as principais funções do grafo:

  \subsection{Construtores} \label{ssec:constructors}

    Nosso grafo possui três construtores:

    \begin{itemize}
      \item O primeiro apenas inicia o grafo, sem nenhum vértice. 
      \item O segundo construtor inicia o grafo com N número de vértices, porém, sem arestas,
      logo é criado um grafo nulo
      \item O terceiro construtor foi feito para a realização dos testes. Ele pega informações do
      grafo a partir de um arquivo .txt, sendo a primeira linha o número de vértices e as linhas 
      seguintes contendo as arestas, assim como os pesos(se tiver).
    \end{itemize}

  \subsection{getters}

    Depois dos construtores, temos as funções do tipo getters, que retornam a quantidade de vértices 
    e de arestas dentro do grafo.

  \subsection{add\_vertex}

    Finalmente, começando com as funcionalidades do grafo, temos a função para adicionar 
    uma vertex isolada ao grafo, adicionando um iterator ao vector. Se a operação for um sucesso, 
    será retornado o index da vértice adicionada.

  \subsection{add\_edge}

    Se houver as vértices especificadas, será adicionado a nova ligação a lista de 
    adjacência e de arestas. Se o peso não for especificado, ele será colocado como zero.
    Por fim, a função retorna um booleano, indicando se foi um sucesso.

  \subsection{print}

    A função print é responsável em imprimir o atual estado do grafo, tanto
    em questão das adjacências, quanto as arestas e seus pesos respectivamente.

  \newpage

  \section{Permutação} \label{sec:permutation}

    Com as funcionalidades gerais do grafo especificadas, é possível agora ir para a 
    implementação do algoritmo de permutação. Na teoria de grafos, permutação significa
    percorrer por todas as vértices uma única vez,seguindo a ordem: [v1,a1,v2,a2...]

    O algoritmo de permutação escolhido foi o busca em profundidade(também conhecido 
    como DFS(Depth-first-search)), a idea do algoritmo é percorrer todos os vértices,
    com o intuito de achar o vértice mais fundo.
    
    Em nossa implementação, o vértice inicial sempre será o "vértice raiz"(index 0), 
    e para memorizar todas as vértices já visitadas, também é utilizado um vetor de cores,
    onde o seu tamanho é igual ao número de vértices, e cada posição representa uma vértice do 
    grafo. Eis as cores utilizadas e seus significados:

    \begin{itemize}
      \item WHITE: Vértice e sua vizinhança ainda não visitado 
      \item YELLOW: Vértice visitado porém não sua vizinhança como todo
      \item RED: Vértice visitado assim como sua vizinhança
    \end{itemize}

    Por fim, vamos dar uma olhada em quais são os passos que o código 
    faz, para chegar ao resultado desejado:

    \begin{itemize}
      \item Iniciar vetor de cores e colocar todas as posições como WHITE
      \item Iniciar loop por todas os vértices 
      \item Se vértice == WHITE, visitá-lo
      
      Ao visitar:
      \begin{itemize}
        \item Se vértice visitado == RED, sair.
        \item Se vértice visitado == YELLOW, ciclo encontrado, ++número de ciclos.
        \item Iniciar loop por todas os vértices adjacentes ao vértice atual 
        \item Se o vértice não for o pai da vértice atual, visitá-lo.
      \end{itemize}
    \end{itemize}

  \section{Caminhamento} \label{sec:walking}

  Caminhamento é uma sequência de vertices e arestas de um grafo. Ao atravessar um grafo,
  um caminhamento ocorre e tanto vértices quando arestas podem ser repetidas neste processo.

  Existe diferentes tipos de caminhamento, porém, para os objetivos desse relatório, isto 
  é o suficiente para entender como implementamos o nosso algoritmo escolhido, que no caso 
  é o de Kruskal.

  O algoritmo de Kruskal, inventado pelo matemático Joseph Kruskal, foi feito para buscar 
  uma árvore geradora mínima(Minimum Spanning Tree), em um grafo conexo e que possua pesos. 
  Então fica a pergunta: se o Kruskal serve para encontrar uma MST, então como podemos usa-lo 
  para encontrar ciclos? 

  Para responder essa pergunta: precisamos entender a lógica do algoritmo:

  \begin{itemize}
    \item Fazer uma ordenação das arestas pelo seus pesos(menor para o maior)
    \item Criar um disjoint-set com o número de vértices do grafo 
    \item Iniciar loop por todas as arestas
    \item Se ligar a aresta atual não formar um ciclo
    
    \begin{itemize}
      \item Adicionar aresta no disjoint-set 
      \item Fazer merge dos conjuntos dentro do disjoint-set
    \end{itemize}
  \end{itemize}

  Para a realização do Kruskal, ele necessita fazer a verificação se um ciclo será formado,
  ao unir as duas arestas, logo, apenas adicionar mais uma verificação e um contador para 
  que seja possível contar o número de ciclos.

  Por fim o Disjoin-sets é uma estrutura separada do grafo, que foi criada para ser utilizada
  apenas no Kruskal. O objetivo de se utilizar Disjoin-sets é para manter o controle dos vértices 
  particionadas em subconjuntos, e então juntá-las a medida que for necessário.

  \section{Desempenho} \label{sec:performance}

  Com a explicação dos grafos deixada de lado, agora será explicado como foi feito os testes de performance.

  Na seção \ref{ssec:constructors}, foi detalhado os construtores do grafo. Entre eles,
  o construtor 3 do grafo foi feito especicamente para realização dos testes. Ele 
  recebe um char* com o diretório de um arquivo ".txt". Esse arquivo possui informações como número de 
  vértices, as relações entre as vértices(arestas), e por fim, se tiver, o peso das arestas.

  Para iniciar o programa, o usuário precisa enviar parâmetros para a função, entre esses parâmetros estão:

  \begin{itemize}
    \item A quantidade de testes a ser feito
    \item Qual método de contagem de ciclo usar ("kruskal" ou "dfs")
    \item O diretório para os arquivos com os grafos
  \end{itemize}

  Ao iniciar o programa com os parâmetros necessários, um número 'n' do teste especificado 
  será realizado nos grafos inseridos, e o resultado será colocado em arquivo("results.txt").
  
  A seguir terá subseções divididas em: esquemática do grafo, assim como 
  uma tabela com informações sobre o teste: número de testes, algoritmo e
  tempo médio.

  \newpage 

  \subsection{Grafo 1}

  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[node distance = 3cm,  auto,main/.style = {draw, circle,minimum size=10mm}] 
      \node[main] (1) at (0,0) {A}; 
      \node[main] (2) at (0,2)  {B}; 
      \node[main] (3) at (2,2)  {C};
      \node[main] (4) at (2,0)  {D};


      \path[-]
      (1) edge              node {1} (2)            
      (2) edge              node {4} (3)
      (3) edge              node {3} (4)
      (3) edge              node {5} (1)
      (1) edge              node {2} (4);
    \end{tikzpicture} 

  \end{figure}

  \begin{table}[htbp]
    \caption{Testes nos algoritmo implementado usando o grafo 1}
    \begin{center}
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Número de}&\multicolumn{2}{|c|}{\textbf{Tempo(em segundos)}} \\
    \cline{2-3} 
    \textbf{testes} & \textbf{\textit{DFS}}& \textbf{\textit{Kruskal}} \\
    \hline
    10$^{\mathrm{1}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{2}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{3}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{4}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{5}}$& 0.115 & 0.115 \\
    \hline
    \end{tabular}
    \end{center}
  \end{table}

  \newpage

  \subsection{Grafo 2}

  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[node distance = 3cm,  auto,main/.style = {draw, circle,minimum size=10mm}] 
      \node[main] (1) at (-10,5) {A}; 
      \node[main] (2) at (-8,7)  {B}; 
      \node[main] (3) at (-8,3)  {C};
      \node[main] (4) at (-5,7)  {D};
      \node[main] (5) at (-6,5)  {E}; 
      \node[main] (6) at (-3,4)  {G};   
      \node[main] (7) at (-4,2)  {H};   
      \node[main] (8) at (-1,3)  {I};  
      \node[main] (9) at (-1,6) {J};        
      \node[main] (10) at (1,6)  {K};  

      \path[-]
      (1) edge              node {6}  (2)            
      (1) edge              node {15} (3)
      (3) edge              node {4}  (2)
      (2) edge              node {13} (4)
      (2) edge              node {5}  (5)
      (5) edge              node {8}  (6)
      (6) edge              node {20} (7)
      (6) edge              node {17} (8)
      (6) edge              node {9}  (9)
      (8) edge              node {12} (9)
      (9) edge              node {1}  (10);
    \end{tikzpicture} 

  \end{figure}

  \begin{table}[htbp]
    \caption{Testes nos algoritmo implementado usando o grafo 1}
    \begin{center}
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Número de}&\multicolumn{2}{|c|}{\textbf{Tempo(em segundos)}} \\
    \cline{2-3} 
    \textbf{testes} & \textbf{\textit{DFS}}& \textbf{\textit{Kruskal}} \\
    \hline
    10$^{\mathrm{1}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{2}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{3}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{4}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{5}}$& 0.115 & 0.115 \\
    \hline
    \end{tabular}
    \end{center}
  \end{table}

  \newpage

  \subsection{Grafo 3}

  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[scale=1.5,node distance = 3cm, auto, main/.style = {draw, circle,minimum size=10mm}] 
      \node[main] (1) at (0,0)   {A}; 
      \node[main] (2) at (2,0)   {B}; 
      \node[main] (3) at (4,0)   {C};
      \node[main] (4) at (6,0)   {D};
      \node[main] (5) at (1,-2)  {E}; 
      \node[main] (6) at (3,-2)  {G};   
      \node[main] (7) at (5,-2)  {H};   
      \node[main] (8) at (0,-4)  {I};   
      \node[main] (9) at (2,-4)  {J}; 
      \node[main] (10) at (4,-4)  {K};  
      \node[main] (11) at (6,-4)  {L};   
      \node[main] (12) at (1,-6)  {M}; 
      \node[main] (13) at (3,-6)  {N};   
      \node[main] (14) at (5,-6)  {O};  
      \node[main] (15) at (0,-8)   {P}; 
      \node[main] (16) at (2,-8)   {Q}; 
      \node[main] (17) at (4,-8)   {R};
      \node[main] (18) at (6,-8)   {S};

      \path[-]
      (1)  edge                 node {4}  (5)
      (5)  edge                 node {1}  (2)
      (2)  edge                 node {10}  (3)
      (3)  edge                 node {3}  (4)
      (5)  edge                 node {6}  (6)
      (6)  edge                 node {21}  (7)
      (2)  edge                 node {59}  (6)
      (3)  edge                 node {28}  (6)
      (3)  edge                 node {9}  (7)
      (4)  edge                 node {48}  (11)
      (7)  edge                 node {24}  (11)
      (11) edge                 node {15}  (18)
      (6)  edge                 node {7}  (10)
      (10) edge                 node {58}  (9)
      (6)  edge                 node {29}  (9)
      (8)  edge                 node {50}  (9)
      (11) edge                 node {49}  (14)
      (14) edge                 node {21}  (17)
      (9)  edge                 node {2}  (13)
      (13) edge                 node {55}  (17)
      (17) edge                 node {30}  (16)
      (16) edge                 node {11}  (15)
      (15) edge [bend left=20]  node {13}  (1)
      (16) edge                 node {19}  (12)
      (18) edge                 node {22}  (14);

    \end{tikzpicture} 

  \end{figure}

  \begin{table}[htbp]
    \caption{Testes nos algoritmo implementado usando o grafo 1}
    \begin{center}
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Número de}&\multicolumn{2}{|c|}{\textbf{Tempo(em segundos)}} \\
    \cline{2-3} 
    \textbf{testes} & \textbf{\textit{DFS}}& \textbf{\textit{Kruskal}} \\
    \hline
    10$^{\mathrm{1}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{2}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{3}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{4}}$& 0.115 & 0.115 \\
    \hline
    10$^{\mathrm{5}}$& 0.115 & 0.115 \\
    \hline
    \end{tabular}
    \end{center}
  \end{table}

  \newpage
  
  \section{Conclusão} \label{sec:conclusion}
\end{document}