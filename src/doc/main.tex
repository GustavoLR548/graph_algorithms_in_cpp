\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}  

     
\sloppy

\title{Estudo de diferentes formas de enumeração de ciclos em um grafo}

\author{Gustavo Lopes Rodrigues\inst{1}, Thiago Henriques Nogueira\inst{2},}


\address{Instituto de Ciências e Informática \\Pontifícia Universidade Católica de Minas Gerais
  (PUC-MG)\\}


\begin{document} 

\maketitle

\begin{abstract} 
  This document serves as a report on the study in two different ways
  to enumerate cycles within a graph: permutation and walking. For this
  study, we only work with non-directed graphs. In order to test the effiency 
  of both algorythms,we also implemented a method to calculate the performance of walking
  X permutation as the graph increases.
\end{abstract}

\begin{resumo} 
  Este documento serve é um relatório sobre o estudo em duas maneiras 
  diferentes de enumerar ciclos dentro de um grafo: permutação e por caminhamento. Para esse 
  estudo, trabalhamos apenas com grafos não-direcionado. Então fizemos um método
  para calcular o desempenho do caminhamento e da permutação, na medida que o grafo aumentasse.
\end{resumo}


\section{Informações gerais}

  Este é um trabalho feita para a disciplina de Algoritmo em Grafos, para a 
  \emph{Pontifícia Universidade Católica de Minas Gerais}, onde foi necessário 
  implementar duas maneiras diferentes de enumerar todos os ciclos dentro de um 
  grafo não direcionado: permutação e caminhamento. O objetivo final  deste relatório, 
  é de descrever toda a implementação do grafo e da resolução do problema, assim como 
  comparar ambos os algoritmos em questão do desempenho.

  Na seção \ref{sec:graph}, detalhamos a estrutura de grafo que foi usada para essa atividade,
  assim também como os seus principais componentes. Em \ref{sec:permutation} e \ref{sec:walking},
  detalhamos como implementos os nossos algoritmos de permutação e caminhamento respectivamente.
  A seção \ref{sec:performance} é a demonstração da performance dos códigos, assim como também 
  os grafos utilizados para os testes e como fizemos os testes. Por fim, na seção \ref{sec:conclusion}
  concluímos o trabalho com nossas perspectivas.

  \section{Grafo} \label{sec:graph}

  A classe graph.cpp é onde ocorre a maior parte das operações
  
  Para armazenar os vertíces, foi escolhido utilizar o std::vector, pois além 
  dele ser uma estrutura mais flexível ele possui acesso direto do index do 
  array a partir da função .at().

  No caso das arestas foi utilizado uma matriz para o armazenamento das 
  relações de adjacência. Isso deve ao fato dela ser flexível, possibilitando
  a ligação do par de vertíces ao qual ela é originada.

  Entre as funcionalidades da classe, se encontram na seção abaixo as mais importantes

  \section{Permutação} \label{sec:permutation}

  \section{Caminhamento} \label{sec:walking}

  \section{Desempenho} \label{sec:performance}

  \section{Conclusão} \label{sec:conclusion}
\end{document}